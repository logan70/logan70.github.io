---
layout: post
title:  "学习webpack4"
categories: HTML
date:   2018-05-04 11:48:05
author: Logan
tags:  responsive
---

* content
{:toc}

[TOC]

# 相关知识

## 一个错误犯了两次
`module.exports`误写为`module.export`,导致打包时报错

## `path.join()`与`path.resolve()`的区别

> `path`是`node.js`的内置模块，提供了一些工具函数，用于处理文件与目录的路径。

> `__dirname`：获得当前执行文件所在目录的完整目录名，即绝对路径

**path.join()**

- `path.join()` 方法使用平台特定的分隔符把全部给定的 path 片段连接到一起，并规范化生成的路径。
- 可以理解为`path.join()`是将各个path片段连接在一起，即进行字符串拼接，但是遇到`..`还是会解析

```js
path.join('/foo', 'bar', 'baz/asdf', 'quux');
// 返回: '/foo/bar/baz/asdf/quux'

path.join('/foo', 'bar', 'baz/asdf', 'quux', '..');
// 返回: '/foo/bar/baz/asdf'
```


**path.resolve()**

- `path.resolve()` 方法会把一个路径或路径片段的序列解析为一个绝对路径。
- `path.resolve()`会将`/xxx`解析为绝对路径
- `path.resolve()`将参数从右往左解析，直到构造完成一个绝对路径。

```js
path.resolve('/foo/bar', './baz');
// 返回: '/foo/bar/baz'

path.resolve('/foo/bar', '/tmp/file/');
// 返回: '/tmp/file'
```

# 一、Webpack介绍

- webpack是什么
  - webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。
- webpack的作用
  -  打包（把多个文件打包成一个js文件，减少服务器压力、带宽）
  -  转化（less/sass/ts）需要loader
  -  优化（SPA越来越盛行，前段项目复杂度高，webpack可以对项目进行优化）
- webpack的构成
  - entry 入口
  - output 出口
  - loaders 转化器
  - plugins 插件
  - devSever 开发服务器
  - mode 开发模式 development/production







# 二、Webpack的安装及初始化

```js
npm i webpack webpack-cli webpack-dev-server -g  // 全局安装webpack

// 初始化文件夹及文件（powershell）
mkdir learn-webpack4                             // 创建并进入总文件夹
cd learn-webpack4

npm init -y

mkdir src                                        // 创建子文件夹
mkdir dist
mkdir config

New-Item src/index.js
New-Item dist/index.html
New-Item webpack.config.js
```

# 三、`package.json`配置

```js
{
  "name": "learn-webpack4",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "dependencies": {...},
  "devDependencies": {...},
  "scripts": {
    "dev": "webpack-dev-server", // 开发环境
    "build": "webpack" // 生产环境
  },
  "keywords": [],
  "author": "",
  "license": "ISC"
}
```

配置好之后，即可通过快捷命令`npm run dev` 和 `npm run build` 来启动webpack

# 四、`webpack.dev.js`初步配置

```js
const path = require('path')
module.exports = {
  // 入口：有且可以有多个，数组形式
  entry: {
    main: ['./src/index.js']
  },
  // 打包环境：开发 & 生产
  mode: 'development',
  // 出口：有且只能有一个
  output: {
    filename: '[name]-bundle.js',
    path: path.resolve(__dirname, '../dist'),
    publicPath: '/'       // 对外暴漏的公共路径
  },
  // 本地服务器配置
  devServer: {
    contentBase: 'dist'
  }
}
```

# 五、处理Js文件

## 1. 安装babel

处理js文件我们需要用到babel,先安装一下

```
npm i babel-loader babel-core -D
```

## 2. 安装 `babel-preset-env`和`babel-preset-stage-0`

```
npm i babel-preset-env babel-preset-stage-0 --D
```

**babel-preset-env介绍**

`babel-preset-env`能根据当前的运行环境，自动确定你需要的 plugins 和 polyfills。

```js
{
  "presets": [
    [
      "env",
      {
        "targets": { // 配支持的环境
          "browsers": [ // 浏览器
            "last 2 versions",
            "safari >= 7"
          ],
          "node": "current" // 通过Babel编译你的Node.js代码，支持的是当前运行版本的nodejs
        },
        "modules": true,
        "debug": true,
        "useBuiltIns": false,
        "include": [],
        "exclude": []
      }
    ]
  ],
  plugins: []
}
```

- `target.browsers`: 指定相应的浏览器配置
    ```
    // 例子
    "browsers": ["> 1%", "last 2 versions", "not ie <= 8"]
    ```
- `target.node`: 如果你通过Babel编译你的Node.js代码，`targets.node: "current"`，支持的是当前运行版本的nodejs
- `modules`: 将ES6语法转换为另一种模块模型
    可选值："amd"、 "commonjs"、 "systemjs"、 "umd"
    设置为false则禁止转译模块语法
    > webpack已经把这个事情做了，所以就不需要babel来做了，但是babel配置项中的modules默认值是commonjs，所以你需要将modules设置为false才行，不然就冲突了。
- `include`: 必须要转译的功能，跟单独启用相应插件是一样的。
- `exclude`: 禁止转译的功能
- `useBuiltIns`:默认值: false。设置为true可以实现`babel-preset-env`基于特定环境引入需要的polyfill。
    ```
    // 使用方法
    npm i babel-polyfill // 安装 polyfill
    import 'babel-polyfill // 在入口js处引入
    ```
    最终都会根据环境转译成特定的polyfill。 比如:
    ```
    require('core-js/modules/es6.typed.array-buffer');
    require('core-js/modules/es6.typed.int8-array');
    ```

    > 在整个应用里只能引入一次polyfill，可以在 `index.js` 里一次引入。<br/>
    > `useBuiltIns` 会使浏览器下载的代码变少 (最终打包的文件大小变小了)。但是不会节约内存， 因为polyfill本身只会安装缺少的部分。
- `debug`: 默认为false，设置为true则console.log输出**目标环境、启用的transforms、启用的plugins、启用的polyfills**

**babel-preset-stage-0是对 ES7 支持的插件**



## 3. 浏览器兼容及性能问题

为防止浏览器不支持 Promise/Object.assign/Array.from等还有性能问题,我们引入`babel-polyfill`: 

```
npm i babel-polyfill -S
```

在入口文件引入`babel-polyfill`

```
import 'babel-polyfill'
```

## 4. 配置`.babelrc`

    在根目录下创建`.babelrc`
    ```
    {
      "presets": [
        ["env", {
          "modules": false, // 设置为false禁止转译模块语法
          "debug": true,// 开启debug模式，编译时会显示配置的信息
          "targets": {
            // 配置浏览器支持信息
            "browsers": ["> 1%", "last 2 versions", "not ie <= 8"] 
          },
          "useBuiltIns": true // 引入需要的polyfill而不是全部
        }],
        "stage-0" // es7支持
      ]
    }
    ```

## 5. 配置加载器（loader）

```js
// js loader
{
  test: /\.js$/,
  use: [
    {
      loader: 'babel-loader',
      include: path.resolve(__dirname , 'src'),
      exclude: /node_modules/
    }
  ]
}
``` 


# 六、加载css

1. 在`src`目录下创建一个`style.css`的样式文件,并进行编写
2. 在`src/index.js`内引入创建的css
  
  ```js
  require('./style.css')
  //...
  ```
3. 配置加载器（loaders）
    - npm安装相关加载器
    ```
    npm i style-loader css-loader -D
    ```
    - 在`config/webpack.dev.js`内进行配置
    ```js
    const path = require('path')
    module.exports = {
      // 入口：有且可以有多个，数组形式/对象形式/二者结合
      entry: {...},
      // 打包环境：开发 & 生产
      mode: 'development',
      // 出口：有且只能有一个
      output: {...},
      // 本地服务器配置
      devServer: {...},
      module: {
        rules: [
          {
            test: /\.css$/,
            use: [
              {
                loader: 'style-loader'
              },
              {
                loader: 'css-loader'
              }
            ]
          }
        ]
      }
    }
    ```
4. 运行DevServer查看效果
```
npm run dev
```

# 七、加载html

1. 将`dist/index.html`移动至`src/index.html`
2. 在`src/index.js`内引入html
  
  ```js
  require('./index.html')
  //...
  ```

3. 配置加载器（loaders）
    - npm安装相关加载器
    ```
    npm i file-loader extract-loader html-loader -D
    ```
    - 在`config/webpack.dev.js`内进行配置
    ```js
    const path = require('path')
    module.exports = {
      // 入口：有且可以有多个，数组形式/对象形式/二者结合
      entry: {...},
      // 打包环境：开发 & 生产
      mode: 'development',
      // 出口：有且只能有一个
      output: {...},
      // 本地服务器配置
      devServer: {...},
      module: {
        rules: [
          // css loaders
          {...},
          // html loaders
          {
            test: /\.html$/,
            use: [
              {
                loader: 'file-loader',
                options: {
                  name: '[name].[ext]'
                }
              },
              {
                loader: 'extract-loader'
              },
              {
                loader: 'html-loader',
                options: {
                  attrs: ["img: src"]            // 配置加载图片
                }
              }
            ]
          }
        ]
      }
    }
    ```
4. 打包查看效果
```
npm run build
```

# 八、加载图片

1. 配置加载器（loaders）

在`config/webpack.dev.js`内进行配置
```js
const path = require('path')
module.exports = {
  // 入口：有且可以有多个，数组形式/对象形式/二者结合
  entry: {...},
  // 打包环境：开发 & 生产
  mode: 'development',
  // 出口：有且只能有一个
  output: {...},
  // 本地服务器配置
  devServer: {...},
  module: {
    rules: [
      // css loaders
      {...},
      // html loaders
      {...}
      // image loader
      {
        test: /\.(jpe?g|png|gif|svg)$/,
        use: [
          {
            loader: 'file-loader',
            name: 'image/[name].[hash].[ext]'
          }
        ]
      }
    ]
  }
}
```
